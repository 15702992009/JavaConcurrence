Package java.util.concurrent.locks

Interfaces and classes providing a framework for locking and waiting for conditions that is distinct from built-in synchronization and monitors. The framework permits much greater flexibility in the use of locks and conditions, at the expense of more awkward syntax.
The Lock interface supports locking disciplines that differ in semantics (reentrant, fair, etc), and that can be used in non-block-structured contexts including hand-over-hand and lock reordering algorithms. The main implementation is ReentrantLock.

The ReadWriteLock interface similarly defines locks that may be shared among readers but are exclusive to writers. Only a single implementation, ReentrantReadWriteLock, is provided, since it covers most standard usage contexts. But programmers may create their own implementations to cover nonstandard requirements.

The Condition interface describes condition variables that may be associated with Locks. These are similar in usage to the implicit monitors accessed using Object.wait, but offer extended capabilities. In particular, multiple Condition objects may be associated with a single Lock. To avoid compatibility issues, the names of Condition methods are different from the corresponding Object versions.

The AbstractQueuedSynchronizer class serves as a useful superclass for defining locks and other synchronizers that rely on queuing blocked threads. The AbstractQueuedLongSynchronizer class provides the same functionality but extends support to 64 bits of synchronization state. Both extend class AbstractOwnableSynchronizer, a simple class that helps record the thread currently holding exclusive synchronization. The LockSupport class provides lower-level blocking and unblocking support that is useful for those developers implementing their own customized lock classes.