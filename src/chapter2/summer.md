# java并发编程的底层实现原理  
## 2.1 volatile的应用  
volatile的实现原理：1. 通过Lock指令 2. 缓存一致性  
1. Lock前缀指令会引起处理器缓存回写到内存  
2. 这个回写内存操作会使其他CPU里缓存了该内存地址的数据无效  
缓存一致性：在多处理器下，为了保证各个处理器缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当
处理器对这条数据进行修改时，会重新从系统内存把数据读取到处理器缓存里。MESI(修改，独占，共享，无效)
## 2.2 synchronized的实现原理与应用  
synchronize的实现基础： java的每一个对象都可以看作锁  
Java对象头由三部分组成：
1. Mark Word（存储对象的hashCode或锁信息）
2. Class Metadata 存储到对象类型数据的指针  
3. Array length 数组的长度  
  
锁的四种状态：
1. 无锁  
2. 偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试对象头里面的Mark Word是否存储着指向当前线程的偏向锁  
3. 轻量级锁：
    1. 加锁：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。成功说明获得锁，失败，表示其他线程竞争锁，当前线程会进入自旋状态来获取锁
    2. 解锁：使用原子的CAS操作将Displace Mark Word替换回对象头。
4. 重量级锁  
锁只能升级不能降级， 
## 2.3原子操作的实现原理   
**1. 术语定义:**   
1. 缓存行：缓存的最小单位  
2. 比较并交换：CAS操作需要输入两个数值，一个旧值和一个新值。在操作期间先比较旧值是否发生变化，如果没有发生变化，才交换新值，发生变化则不置换  
3. CPU流水线  
4. 内存顺序冲突   

**2. 处理器如何实现原子操作**   
1. 总线锁：使用处理器提供的LOCK#信号，当处理器在总线上输出此信号时，其他处理器的请求将被阻塞，那么该处理器可以独占共享内存。  
2. 缓存锁：通过缓存一致性来保证原子性  

**3. JAVA如何实现原子操作**  
在Java中可以通过锁和循环CAS的方式来实现原子操作  
1. 使用循环的CAS来实现原子操作  
2. CAS实现原子操作的三大问题  
    1. ABA问题
    2. 循环时间长开销大
    3. 只能保证一个共享变量的原子操作 
3.使用锁机制实现原子操作    
